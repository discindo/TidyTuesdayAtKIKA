---
title: "Tidy Tuesday 43 / 2019"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width = 12, fig.height = 8, fig.path = 'figures3/',
                      echo = TRUE, eval = FALSE, warning = FALSE, message = FALSE)
```


Libraries

```{r}
library(tidyverse)
```


Load the data

```{r}
horror_movies <- readr::read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-10-22/horror_movies.csv")
```


```{r}
glimpse(horror_movies)
```

# Што треба да се поправи во податоците?
- **release_date** да биде соодветен датум формат а на **<chr>**;
- **movie_run_time** можеби треба да се вика **mins** и да ги има само минутите во колоната;
- **budget** да биде една валута; 

# Идеи за графици?
- Wordcloud за plot?
- Мапа на локации за снимање?
- Однос помеѓу под-жанрови и буџет, времетраење на филм, и рејтинг 

# Wordcloud за заплетот на филмовите

```{r}
#install.packages('ggwordcloud')
#install.packages("tidytext")
#there are alternatives: wordcloud and tm 

library(ggwordcloud)
library(tidytext)
```

```{r}
txtplot <- horror_movies %>% 
  select(matches("plot")) %>% 
  unnest_tokens(word, plot) %>% 
  dplyr::count(word, sort = TRUE)
```


Чистење на податоците од т.н. stop words и бројки
```{r}
data("stop_words")
txtplot_clean <- txtplot %>%
  anti_join(stop_words)
```

```{r}
# remove numbers
nums <-  txtplot_clean %>% 
  filter(str_detect(word, "^[0-9]")) %>% 
  select(word) %>% 
  unique()

txtplot_clean <- txtplot_clean %>% 
  anti_join(nums, by = "word")
```


```{r}
# remove unique stop words that snuck in there
uni_sw <- data.frame(word = c("directed","michael","john", "david", "james", "film", "horror"))

txtplot_clean <- txtplot_clean %>% 
  anti_join(uni_sw, by = "word")
```

#Plot the the horro plots
```{r}
words_to_plot <-  top_n(txtplot_clean, 15, wt = n)

img <- png::readPNG("./halloween-pumpkin-xxl.png")

ggplot(words_to_plot) +
  aes(label = word) +
  aes(size = n, color = n) +
  geom_text_wordcloud() + 
  scale_size_area(max_size = 24) +
  theme_void() + 
  scale_color_gradient(low = "darkred", high = "red") +
  ggpubr::background_image(img)

```

## Ratings

```{r}
horror_movies <-
  readr::read_csv(
    "https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-10-22/horror_movies.csv"
  )
```

How do budget and rating relate to genres? Is a horror movie more likely to be highly rated if
it is also a comedy vs. drama vs. thriller. 

Parse the genres of a movie. My approach was to create a column for each genre and record whether a movie is classified (TRUE) as that genre

```{r}
# first, a list of unique genres
(
  genres <- horror_movies %>%
    pull(genres) %>%
    str_split(pattern = "\\| ") %>%
    unlist %>%
    sort %>%
    unique
)
```

There are many subgenres, so do a count and take the most common ones (keep subgenres with at least 100 movies)

```{r}
(
  common_genres <- horror_movies %>%
    pull(genres) %>%
    str_split(pattern = "\\| ") %>%
    unlist %>%
    table %>%
    as_tibble() %>%
    arrange(desc(n)) %>%
    filter(n > 100) %>%
    pull(1)
)
```

Now add 10 columns to the horror_movies dataset

```{r}
for (i in seq_along(common_genres)) {
  horror_movies[[common_genres[i]]] <-
    ifelse(str_detect(horror_movies$genres, common_genres[i]), common_genres[i], NA)
}

glimpse(horror_movies)
```

Now we can convert to long format such that we have one column for the different genres after parsing

```{r}
hm <-
  horror_movies %>% 
  pivot_longer(cols = common_genres,
               names_to = "parsed_genres",
               values_to = "parsed_values")
```

Plot:

Review ratings

```{r}
# filter for only secondary genres
hm %>% filter(!is.na(parsed_values), !parsed_values == "Horror") %>%
  ggplot(data = .) +
  aes(x = parsed_values) +
  aes(y = review_rating) +
  geom_violin(alpha = .6, draw_quantiles = c(0.95, 0.75, 0.5, 0.25, 0.5), trim = TRUE) +
  coord_flip() 
```

Movie run time

```{r}
# filter for only secondary genres
hm %>% filter(!is.na(parsed_values), !parsed_values == "Horror") %>%
  mutate(mrt=str_remove(movie_run_time, " min") %>% as.numeric()) %>% 
  ggplot(data = .) +
  aes(x = parsed_values) +
  aes(y = mrt) +
  geom_violin(alpha = .6, draw_quantiles = c(0.95, 0.75, 0.5, 0.25, 0.5), trim = TRUE) +
  coord_flip()
```


Budget, needs to be cleaned

```{r}
hm %>% mutate(budget_num = readr::parse_number(budget)) %>% 
  ggplot(data = .) +
  aes(x = parsed_values) +
  aes(y = budget_num) +
  geom_violin(alpha = .6, draw_quantiles = c(0.95, 0.75, 0.5, 0.25, 0.5), trim = TRUE) +
  scale_y_continuous(trans="log10", breaks=10^(1:10), labels = scales::dollar_format()) +
  coord_flip() +
  theme(axis.text.x = element_text(angle=45, hjust=1, vjust=1))
```

